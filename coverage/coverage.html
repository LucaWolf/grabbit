
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>grabbit: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/LucaWolf/grabbit/channel.go (0.0%)</option>
				
				<option value="file1">github.com/LucaWolf/grabbit/channel_consume.go (0.0%)</option>
				
				<option value="file2">github.com/LucaWolf/grabbit/channel_notifiers.go (0.0%)</option>
				
				<option value="file3">github.com/LucaWolf/grabbit/channel_options.go (0.0%)</option>
				
				<option value="file4">github.com/LucaWolf/grabbit/channel_safebase.go (0.0%)</option>
				
				<option value="file5">github.com/LucaWolf/grabbit/channel_safewrappers.go (0.0%)</option>
				
				<option value="file6">github.com/LucaWolf/grabbit/clienttype_string.go (0.0%)</option>
				
				<option value="file7">github.com/LucaWolf/grabbit/confirmationoutcome_string.go (0.0%)</option>
				
				<option value="file8">github.com/LucaWolf/grabbit/connection.go (73.9%)</option>
				
				<option value="file9">github.com/LucaWolf/grabbit/connection_options.go (75.0%)</option>
				
				<option value="file10">github.com/LucaWolf/grabbit/connection_safebase.go (70.0%)</option>
				
				<option value="file11">github.com/LucaWolf/grabbit/connection_safewrappers.go (60.0%)</option>
				
				<option value="file12">github.com/LucaWolf/grabbit/consumer.go (0.0%)</option>
				
				<option value="file13">github.com/LucaWolf/grabbit/consumer_options.go (0.0%)</option>
				
				<option value="file14">github.com/LucaWolf/grabbit/error.go (22.2%)</option>
				
				<option value="file15">github.com/LucaWolf/grabbit/events.go (100.0%)</option>
				
				<option value="file16">github.com/LucaWolf/grabbit/eventtype_string.go (0.0%)</option>
				
				<option value="file17">github.com/LucaWolf/grabbit/general_options.go (70.0%)</option>
				
				<option value="file18">github.com/LucaWolf/grabbit/publisher.go (0.0%)</option>
				
				<option value="file19">github.com/LucaWolf/grabbit/publisher_options.go (0.0%)</option>
				
				<option value="file20">github.com/LucaWolf/grabbit/topology_options.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package grabbit

import (
        "context"
        "fmt"

        amqp "github.com/rabbitmq/amqp091-go"
)

// Channel wraps the base amqp channel by creating a managed channel.
type Channel struct {
        baseChan SafeBaseChan   // supporting amqp channel
        conn     *Connection    // managed connection
        paused   SafeBool       // flow status when of publisher type
        opt      ChannelOptions // user parameters
        queue    string         // currently assigned work queue
}

// NewChannel creates a new managed Channel with the given Connection and optional ChannelOptions.
// There shouldn't be any need to have direct access and is recommended
// using a [Consumer] or [Publisher] instead.
//
// The resulting channel inherits the events notifier, context and delayer
// from the master connection but all can be overridden by passing options.
// Use the 'WithChannelOption&lt;OptionName&gt;' for optionFuncs.
//
// Example Usage:
//
//          chan := NewChannel(conn,
//            WithChannelOptionName("myChannel"),
//            WithChannelOptionDown(Down),
//            WithChannelOptionUp(Up),
//                WithChannelOptionRecovering(Reattempting),
//                WithChannelOptionNotification(dataStatusChan),
//            WithChannelOptionContext(ctx),
//          )
//
// Parameters:
//   - conn: The Connection to associate the Channel with.
//   - optionFuncs: An optional list of functions to modify the ChannelOptions.
//
// Returns: A new Channel object.
func NewChannel(conn *Connection, optionFuncs ...func(*ChannelOptions)) *Channel <span class="cov0" title="0">{
        opt := &amp;ChannelOptions{
                notifier:          conn.opt.notifier,
                name:              "default",
                delayer:           conn.opt.delayer,
                cbNotifyPublish:   defaultNotifyPublish,
                cbNotifyReturn:    defaultNotifyReturn,
                cbProcessMessages: defaultPayloadProcessor,
                ctx:               conn.opt.ctx,
        }

        for _, optionFunc := range optionFuncs </span><span class="cov0" title="0">{
                optionFunc(opt)
        }</span>

        <span class="cov0" title="0">ch := &amp;Channel{
                baseChan: SafeBaseChan{},
                opt:      *opt,
                conn:     conn,
        }

        ch.opt.ctx, ch.opt.cancelCtx = context.WithCancel(opt.ctx)

        go func() </span><span class="cov0" title="0">{
                if !ch.reconnectLoop(false) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">ch.manage()</span>
        }()

        <span class="cov0" title="0">return ch</span>
}

// pause marks the channel as paused or unpaused.
//
// It takes a boolean value as a parameter.
// The method raises an event to indicate whether the channel is blocked or unblocked,
// and updates the paused value of the Channel accordingly.
func (ch *Channel) pause(value bool) <span class="cov0" title="0">{
        ch.paused.mu.Lock()
        defer ch.paused.mu.Unlock()

        kind := EventUnBlocked
        if value </span><span class="cov0" title="0">{
                kind = EventBlocked
        }</span>

        <span class="cov0" title="0">Event{
                SourceType: CliChannel,
                SourceName: ch.opt.name,
                Kind:       kind,
        }.raise(ch.opt.notifier)

        ch.paused.value = value</span>
}

// manage keep the channel alive.
//
// It isolates all notifiers from the 'ch' object and handles various
// cases using a select statement. It listens to the context done channel
// to close the channel and return. It also handles other cases such as
// paused status, published confirmations, returned messages, closed
// errors, and cancellation reasons.
//
// Parameters:
//   - ch: a pointer to the Channel object.
//
// Return type: None.
func (ch *Channel) manage() <span class="cov0" title="0">{
        var notifiers PersistentNotifiers
        recovering := true

        for </span><span class="cov0" title="0">{
                if recovering </span><span class="cov0" title="0">{
                        recovering = false
                        notifiers = ch.notifiers()
                        if ch.opt.implParams.IsConsumer </span><span class="cov0" title="0">{
                                go ch.gobble(notifiers.Consumer)
                        }</span>
                }

                <span class="cov0" title="0">select </span>{
                case &lt;-ch.opt.ctx.Done():<span class="cov0" title="0">
                        ch.Close() // cancelCtx() called again but idempotent
                        return</span>
                case status := &lt;-notifiers.Flow:<span class="cov0" title="0">
                        ch.pause(status)</span>
                case confirm, notifierStatus := &lt;-notifiers.Published:<span class="cov0" title="0">
                        if notifierStatus </span><span class="cov0" title="0">{
                                ch.opt.cbNotifyPublish(confirm, ch)
                        }</span>
                case msg, notifierStatus := &lt;-notifiers.Returned:<span class="cov0" title="0">
                        if notifierStatus </span><span class="cov0" title="0">{
                                ch.opt.cbNotifyReturn(msg, ch)
                        }</span>
                case err, notifierStatus := &lt;-notifiers.Closed:<span class="cov0" title="0">
                        if !ch.recover(SomeErrFromError(err, err != nil), notifierStatus) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">recovering = true</span>
                case reason, notifierStatus := &lt;-notifiers.Cancel:<span class="cov0" title="0">
                        if !ch.recover(SomeErrFromString(reason), notifierStatus) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">recovering = true</span>
                }
        }
}

// recover recovers from a channel error and handles the necessary events and callbacks.
//
// Parameters:
//   - ch: a pointer to the Channel object.
//   - err: an OptionalError value representing the error occurred.
//   - notifierStatus: a boolean indicating the status of the notifier.
//
// Returns:
//   - a boolean value indicating whether the recovery was successful.
func (ch *Channel) recover(err OptionalError, notifierStatus bool) bool <span class="cov0" title="0">{
        Event{
                SourceType: CliChannel,
                SourceName: ch.opt.name,
                Kind:       EventDown,
                Err:        err,
        }.raise(ch.opt.notifier)
        // abort by callback
        if !callbackAllowedDown(ch.opt.cbDown, ch.opt.name, err) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !notifierStatus </span><span class="cov0" title="0">{
                ch.baseChan.reset()

                Event{
                        SourceType: CliChannel,
                        SourceName: ch.opt.name,
                        Kind:       EventClosed,
                }.raise(ch.opt.notifier)
        }</span>

        // no err means gracefully closed on demand
        <span class="cov0" title="0">return err.IsSet() &amp;&amp; ch.reconnectLoop(true)</span>
}

// rebase tries to establish a new base channel and returns a boolean indicating success or failure.
// It sends en event notification with either EventUp or EventCannotEstablish, depending
// on the new channel status.
//
// It takes a pointer to a Channel struct as a parameter.
// It returns a boolean value.
func (ch *Channel) rebase() bool <span class="cov0" title="0">{
        kind := EventUp
        result := true
        optError := OptionalError{}

        if super, err := ch.conn.Channel(); err != nil </span><span class="cov0" title="0">{
                kind = EventCannotEstablish
                optError = SomeErrFromError(err, true)
                result = false
        }</span> else<span class="cov0" title="0"> {
                ch.baseChan.set(super)
        }</span>

        <span class="cov0" title="0">Event{
                SourceType: CliChannel,
                SourceName: ch.opt.name,
                Kind:       kind,
                Err:        optError,
        }.raise(ch.opt.notifier)
        callbackDoUp(result, ch.opt.cbUp, ch.opt.name)

        return result</span>
}

// reconnectLoop is a function that performs a reconnection loop for a given channel.
//
// It takes a *Channel pointer as its parameter, which represents the channel to reconnect, and a boolean
// value indicating whether the channel is recovering.
//
// The function returns a boolean value, which indicates whether the reconnection loop was successful or not.
func (ch *Channel) reconnectLoop(recovering bool) bool <span class="cov0" title="0">{
        retry := 0
        for </span><span class="cov0" title="0">{
                retry = (retry + 1) % 0xFFFF
                // not wanted
                if !callbackAllowedRecovery(ch.opt.cbReconnect, ch.opt.name, retry) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if ch.rebase() </span><span class="cov0" title="0">{
                        // cannot decide (yet) which infra is critical, let the caller decide via the raised events
                        ch.makeTopology(recovering)
                        return true
                }</span>
                // context cancelled
                <span class="cov0" title="0">if !delayerCompleted(ch.opt.ctx, ch.opt.delayer, retry) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
}

// makeTopology creates topology for a channel.
//
// The function takes a channel (ch) and a boolean flag (recovering) as parameters.
//
// It creates a local isolated channel (chLocal) and handles any errors that occur during this process.
// It then iterates over the topology of the channel and performs the necessary operations based on the topology configuration.
//   - if the topology element is an exchange, it declares the exchange using the declareExchange function.
//   - if the topology element is a queue, it declares the queue using the declareQueue function.
//   - if the topology element is marked as a destination, it saves a copy of the name for back reference.
//
// Finally, it raises an event for each topology element.
func (ch *Channel) makeTopology(recovering bool) <span class="cov0" title="0">{
        // Channels are not concurrent data/usage wise!
        // prefer using a local isolated channel.
        chLocal, err := ch.conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                Event{
                        SourceType: CliChannel,
                        SourceName: "topology.auto",
                        Kind:       EventCannotEstablish,
                        Err:        SomeErrFromError(err, true),
                }.raise(ch.opt.notifier)
                return
        }</span>
        <span class="cov0" title="0">defer chLocal.Close()

        for _, t := range ch.opt.topology </span><span class="cov0" title="0">{
                if !t.Declare || (recovering &amp;&amp; t.Durable) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var name string
                var optError OptionalError

                if t.IsExchange </span><span class="cov0" title="0">{
                        err := declareExchange(chLocal, t)
                        optError = SomeErrFromError(err, err != nil)
                        name = t.Name
                }</span> else<span class="cov0" title="0"> {
                        queue, err := declareQueue(chLocal, t)
                        optError = SomeErrFromError(err, err != nil)
                        name = queue.Name
                }</span>
                // save a copy for back reference
                <span class="cov0" title="0">if t.IsDestination </span><span class="cov0" title="0">{
                        ch.baseChan.mu.Lock()
                        ch.queue = name
                        ch.baseChan.mu.Unlock()
                }</span>

                <span class="cov0" title="0">Event{
                        SourceType: CliChannel,
                        SourceName: ch.opt.name,
                        TargetName: t.Name,
                        Kind:       EventDefineTopology,
                        Err:        optError,
                }.raise(ch.opt.notifier)</span>
        }
}

// declareExchange is a function that declares an exchange in RabbitMQ.
//
// It takes in a *amqp.Channel and a *TopologyOptions as parameters.
// It returns an error.
func declareExchange(ch *amqp.Channel, t *TopologyOptions) error <span class="cov0" title="0">{
        err := ch.ExchangeDeclare(t.Name, t.Kind, t.Durable, t.AutoDelete, t.Internal, t.NoWait, t.Args)
        if err == nil &amp;&amp; t.Bind.Enabled </span><span class="cov0" title="0">{
                source, destination := t.GetRouting()
                err = ch.ExchangeBind(destination, t.Bind.Key, source, t.Bind.NoWait, t.Bind.Args)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// declareQueue declares a queue and performs additional operations if successful.
//
// Parameters:
//   - ch: Pointer to an amqp.Channel object.
//   - t: Pointer to a TopologyOptions object.
//
// Returns:
//   - amqp.Queue: The declared queue.
//   - error: An error object if there was an issue with the declaration or the additional operations.
func declareQueue(ch *amqp.Channel, t *TopologyOptions) (amqp.Queue, error) <span class="cov0" title="0">{
        queue, err := ch.QueueDeclare(t.Name, t.Durable, t.AutoDelete, t.Exclusive, t.NoWait, t.Args)
        if err == nil </span><span class="cov0" title="0">{
                // sometimes the assigned name comes back empty. This is an indication of conn errors
                if len(queue.Name) == 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("cannot declare durable (%v) queue %s", t.Durable, t.Name)
                }</span> else<span class="cov0" title="0"> if t.Bind.Enabled </span><span class="cov0" title="0">{
                        err = ch.QueueBind(queue.Name, t.Bind.Key, t.Bind.Peer, t.Bind.NoWait, t.Bind.Args)
                }</span>
        }

        <span class="cov0" title="0">return queue, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package grabbit

import (
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

// consumer sets up the consumer feed for the given channel.
//
// It takes a pointer to a Channel as a parameter.
// There is no return value.
func (ch *Channel) consumer() &lt;-chan amqp.Delivery <span class="cov0" title="0">{
        if err := ch.baseChan.super.Qos(ch.opt.implParams.PrefetchCount, ch.opt.implParams.PrefetchSize, ch.opt.implParams.QosGlobal); err != nil </span><span class="cov0" title="0">{
                Event{
                        SourceType: CliChannel,
                        SourceName: ch.opt.name,
                        Kind:       EventQos,
                        Err:        SomeErrFromError(err, true),
                }.raise(ch.opt.notifier)
        }</span>
        // overwrite the passed queue to consume with the server assigned value
        <span class="cov0" title="0">qName := ch.opt.implParams.ConsumerQueue
        if len(ch.queue) != 0 </span><span class="cov0" title="0">{
                qName = ch.queue // only when IsDestination
        }</span>

        <span class="cov0" title="0">consumer, err := ch.baseChan.super.Consume(qName,
                ch.opt.implParams.ConsumerName,
                ch.opt.implParams.ConsumerAutoAck,
                ch.opt.implParams.ConsumerExclusive,
                ch.opt.implParams.ConsumerNoLocal,
                ch.opt.implParams.ConsumerNoWait,
                ch.opt.implParams.ConsumerArgs)

        if err != nil </span><span class="cov0" title="0">{
                Event{
                        SourceType: CliChannel,
                        SourceName: ch.opt.name,
                        Kind:       EventConsume,
                        Err:        SomeErrFromError(err, true),
                }.raise(ch.opt.notifier)
        }</span>

        <span class="cov0" title="0">return consumer</span>
}

// gobble runs the consumer function.
//
// It consumes messages from the given channel and processes them.
// When messages are received, they are stored in a slice called messages and processed when
// the number of messages reaches a certain count or the prefetch timeout is reached.
//
// Parameters:
//   - consumer: a channel of amqp.Delivery for receiving messages.
func (ch *Channel) gobble(consumer &lt;-chan amqp.Delivery) <span class="cov0" title="0">{
        var props DeliveriesProperties
        mustAck := !ch.opt.implParams.ConsumerAutoAck
        messages := make([]DeliveryData, 0, ch.opt.implParams.PrefetchCount)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ch.opt.ctx.Done():<span class="cov0" title="0"> // main chan and notifiers.Consumers should also be gone
                        ch.Cancel(ch.opt.implParams.ConsumerName, true)
                        if len(messages) != 0 </span><span class="cov0" title="0">{
                                // conn/chan are gone, cannot ACK/NAK anyways
                                mustAck = false
                                ch.opt.cbProcessMessages(&amp;props, messages, mustAck, ch)
                        }</span>
                        <span class="cov0" title="0">return</span>
                case msg, ok := &lt;-consumer:<span class="cov0" title="0"> // notifiers data
                        if !ok </span><span class="cov0" title="0">{
                                ch.Cancel(ch.opt.implParams.ConsumerName, true)
                                if len(messages) != 0 </span><span class="cov0" title="0">{
                                        // conn/chan are gone, cannot ACK/NAK anyways
                                        mustAck = false
                                        ch.opt.cbProcessMessages(&amp;props, messages, mustAck, ch)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        // set props
                        <span class="cov0" title="0">if len(messages) == 0 </span><span class="cov0" title="0">{
                                props = DeliveryPropsFrom(&amp;msg)
                        }</span>
                        // set data payload
                        <span class="cov0" title="0">messages = append(messages, DeliveryDataFrom(&amp;msg))

                        // process
                        if len(messages) == ch.opt.implParams.PrefetchCount </span><span class="cov0" title="0">{
                                if len(messages) != 0 </span><span class="cov0" title="0">{
                                        ch.opt.cbProcessMessages(&amp;props, messages, mustAck, ch)
                                }</span>
                                <span class="cov0" title="0">messages = make([]DeliveryData, 0, ch.opt.implParams.PrefetchCount)</span>
                        }

                case &lt;-time.After(ch.opt.implParams.PrefetchTimeout):<span class="cov0" title="0">
                        kind := EventDataExhausted
                        if len(messages) != 0 </span><span class="cov0" title="0">{
                                kind = EventDataPartial
                                ch.opt.cbProcessMessages(&amp;props, messages, mustAck, ch)
                                messages = make([]DeliveryData, 0, ch.opt.implParams.PrefetchCount)
                        }</span>

                        <span class="cov0" title="0">Event{
                                SourceType: CliChannel,
                                SourceName: ch.opt.name,
                                Kind:       kind,
                        }.raise(ch.opt.notifier)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package grabbit

import amqp "github.com/rabbitmq/amqp091-go"

// PersistentNotifiers are channels that have the lifespan of the channel. Only
// need refreshing when recovering.
type PersistentNotifiers struct {
        Published chan amqp.Confirmation // publishing confirmation
        Returned  chan amqp.Return       // returned messages
        Flow      chan bool              // flow control
        Closed    chan *amqp.Error       // channel closed
        Cancel    chan string            // channel cancelled
        Consumer  &lt;-chan amqp.Delivery   // message intake
}

// notifiers refreshes the notifiers of a channel and returns the notifier channels.
// For publisher channels, it sets up notifiers for various events such as channel closure, cancellation, flow control, publishing confirmation,
// and returned messages. It also calls the Confirm method on baseChan.super to enable publisher confirms.
// For consumer channels, it calls the consumerSetup function to perform setup actions, and then starts a goroutine to run the consumer.
//
// It takes a pointer to a Channel as a parameter and returns PersistentNotifiers.
func (ch *Channel) notifiers() PersistentNotifiers <span class="cov0" title="0">{
        ch.baseChan.mu.RLock()
        defer ch.baseChan.mu.RUnlock()

        notifiers := PersistentNotifiers{}

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                notifiers.Closed = ch.baseChan.super.NotifyClose(make(chan *amqp.Error))
                notifiers.Cancel = ch.baseChan.super.NotifyCancel(make(chan string))

                // these are publishers specific
                if ch.opt.implParams.IsPublisher </span><span class="cov0" title="0">{
                        notifiers.Flow = ch.baseChan.super.NotifyFlow(make(chan bool))
                        notifiers.Published = ch.baseChan.super.NotifyPublish(make(chan amqp.Confirmation, ch.opt.implParams.ConfirmationCount))
                        notifiers.Returned = ch.baseChan.super.NotifyReturn(make(chan amqp.Return))

                        if err := ch.baseChan.super.Confirm(ch.opt.implParams.ConfirmationNoWait); err != nil </span><span class="cov0" title="0">{
                                Event{
                                        SourceType: CliChannel,
                                        SourceName: ch.opt.name,
                                        Kind:       EventConfirm,
                                        Err:        SomeErrFromError(err, true),
                                }.raise(ch.opt.notifier)
                        }</span>
                }
                // consumer actions
                <span class="cov0" title="0">if ch.opt.implParams.IsConsumer </span><span class="cov0" title="0">{
                        notifiers.Consumer = ch.consumer()
                }</span>
        }

        <span class="cov0" title="0">return notifiers</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package grabbit

import (
        "context"
)

// ChanUsageParameters embeds [PublisherUsageOptions] and [ConsumerUsageOptions].
// It is a private member of the ChannelOptions and cen be passed
// via [WithChannelOptionUsageParams].
type ChanUsageParameters struct {
        PublisherUsageOptions
        ConsumerUsageOptions
}

// ChannelOptions represents the options for configuring a channel.
type ChannelOptions struct {
        notifier          chan Event              // feedback channel
        name              string                  // tag for this channel
        delayer           DelayProvider           // how much to wait between re-attempts
        cbDown            CallbackWhenDown        // callback on conn lost
        cbUp              CallbackWhenUp          // callback when conn recovered
        cbReconnect       CallbackWhenRecovering  // callback when recovering
        cbNotifyPublish   CallbackNotifyPublish   // publish notification handler
        cbNotifyReturn    CallbackNotifyReturn    // returned message notification handler
        cbProcessMessages CallbackProcessMessages // user defined message processing routine
        topology          []*TopologyOptions      // the _whole_ infrastructure involved as array of queues and exchanges
        implParams        ChanUsageParameters     // implementation trigger for publishers or consumers
        ctx               context.Context         // cancellation context
        cancelCtx         context.CancelFunc      // aborts the reconnect loop
}

// WithChannelOptionDown returns a function that sets the callback function to be called when the channel is down.
//
// down - The callback function to be called when the channel is down.
// options - The ChannelOptions object to be modified.
func WithChannelOptionDown(down CallbackWhenDown) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.cbDown = down
        }</span>
}

// WithChannelOptionUp returns a function that sets the callback function
// to be executed when the channel is up.
//
// up: the callback function to be executed when the channel is up.
// options: the ChannelOptions to be modified.
//
// returns: a function that modifies the ChannelOptions by setting the
// callback function to be executed when the channel is up.
func WithChannelOptionUp(up CallbackWhenUp) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.cbUp = up
        }</span>
}

// WithChannelOptionRecovering generates a function that sets the callback function to be called when recovering from an error in the ChannelOptions.
//
// Parameters:
//   - recover: a CallbackWhenRecovering function that will be called when recovering from an error in the ChannelOptions.
//
// Returns:
//   - A function that takes a pointer to ChannelOptions and sets the cbReconnect field to the provided recover function.
func WithChannelOptionRecovering(recover CallbackWhenRecovering) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.cbReconnect = recover
        }</span>
}

// WithChannelOptionContext creates a function that sets the context of a ChannelOptions struct.
//
// It takes a context.Context as a parameter and returns a function that takes a pointer to a ChannelOptions struct.
// The returned function sets the ctx field of the ChannelOptions struct to the provided context.
func WithChannelOptionContext(ctx context.Context) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.ctx = ctx
        }</span>
}

// WithChannelOptionDelay returns a function that sets the "delayer" field of the ChannelOptions struct to the given DelayProvider.
//
// Parameters:
// - delayer: The DelayProvider that will be set as the "delayer" field of ChannelOptions.
//
// Return type: A function that takes a pointer to a ChannelOptions struct as its parameter.
func WithChannelOptionDelay(delayer DelayProvider) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.delayer = delayer
        }</span>
}

// WithChannelOptionName creates a function that sets the name field of the ChannelOptions struct.
//
// It takes a string parameter 'name' and returns a function that takes a pointer to the ChannelOptions struct as a parameter.
func WithChannelOptionName(name string) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.name = name
        }</span>
}

// WithChannelOptionNotification provides an application defined
// [Event] receiver to handle various alerts about the channel status.
func WithChannelOptionNotification(ch chan Event) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.notifier = ch
        }</span>
}

// WithChannelOptionTopology returns a function that sets the topology options for a channel.
//
// The function takes a slice of TopologyOptions as a parameter, which specifies the desired topology for the channel.
// It returns a function that takes a pointer to a ChannelOptions struct as a parameter.
// The function sets the topology field of the ChannelOptions struct to the provided topology slice.
func WithChannelOptionTopology(topology []*TopologyOptions) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.topology = topology
        }</span>
}

// WithChannelOptionNotifyPublish returns a function that sets the callback function
// for notifying the publish event in the ChannelOptions.
//
// It takes a single parameter:
// - publishNotifier: the callback function for notifying the publish event.
//
// It returns a function that takes a pointer to ChannelOptions as a parameter.
func WithChannelOptionNotifyPublish(publishNotifier CallbackNotifyPublish) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.cbNotifyPublish = publishNotifier
        }</span>
}

// WithChannelOptionNotifyReturn generates a function that sets the returnNotifier
// callback for a ChannelOptions struct.
//
// It takes a returnNotifier parameter of type CallbackNotifyReturn which represents
// a function that will be called when a return value is received.
//
// The generated function takes an options parameter of type *ChannelOptions and sets
// the cbNotifyReturn field to the provided returnNotifier.
func WithChannelOptionNotifyReturn(returnNotifier CallbackNotifyReturn) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.cbNotifyReturn = returnNotifier
        }</span>
}

// WithChannelOptionProcessor is a function that returns a function which sets the callback
// process messages for the ChannelOptions struct.
//
// The parameter `proc` is a CallbackProcessMessages function that will be assigned to the
// `cbProcessMessages` field of the `ChannelOptions` struct.
//
// The return type of the returned function is `func(options *ChannelOptions)`.
func WithChannelOptionProcessor(proc CallbackProcessMessages) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.cbProcessMessages = proc
        }</span>
}

// WithChannelOptionUsageParams returns a function that sets the implementation parameters of the ChannelOptions struct.
//
// It takes a parameter of type ChanUsageParameters and returns a function that takes a pointer to a ChannelOptions struct.
func WithChannelOptionUsageParams(params ChanUsageParameters) func(options *ChannelOptions) <span class="cov0" title="0">{
        return func(options *ChannelOptions) </span><span class="cov0" title="0">{
                options.implParams = params

        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package grabbit

import (
        "sync"

        amqp "github.com/rabbitmq/amqp091-go"
)

// SafeBaseChan wraps in a concurrency safe way the low level amqp.Channel.
type SafeBaseChan struct {
        super *amqp.Channel // core channel
        mu    sync.RWMutex  // makes this concurrent safe
}

// IsSet checks whether the SafeBaseChan's super field is set.
//
// It does this by acquiring a read lock on the SafeBaseChan's mutex
// and then deferring its release.
//
// Returns true if the super field is not nil, false otherwise.
func (c *SafeBaseChan) IsSet() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return c.super != nil
}</span>

// Super returns the low level amqp channel for direct interactions.
// Use sparingly and prefer using the predefined [Channel] wrapping methods instead.
// Pair usage with the locking/unlocking routines for safety!
func (c *SafeBaseChan) Super() *amqp.Channel <span class="cov0" title="0">{
        return c.super
}</span>

// Lock acquires locking of the low level channel [Super] for amqp operations.
// Use sparingly and fast as this locks-out the channel recovery!
func (c *SafeBaseChan) Lock() <span class="cov0" title="0">{
        c.mu.Lock()
}</span>

// UnLock releases the low level channel [Super] lock.
func (c *SafeBaseChan) UnLock() <span class="cov0" title="0">{
        c.mu.Unlock()
}</span>

// RLock acquires read locking of the low level channel [Super] for amqp operations.
// Use sparingly and fast as this locks-out the channel recovery!
func (c *SafeBaseChan) RLock() <span class="cov0" title="0">{
        c.mu.Lock()
}</span>

// RUnlock releases the low level channel [Super] read lock.
func (c *SafeBaseChan) RUnlock() <span class="cov0" title="0">{
        c.mu.Unlock()
}</span>

// set is a private method for updating the super channel (post recovery)
func (c *SafeBaseChan) set(super *amqp.Channel) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.super = super
}</span>

// reset is a private method for removing the current super channel (pre-recovery)
func (c *SafeBaseChan) reset() <span class="cov0" title="0">{
        c.set(nil)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package grabbit

import (
        "context"

        amqp "github.com/rabbitmq/amqp091-go"
)

// IsPaused returns a publisher's flow status of the base channel.
func (ch *Channel) IsPaused() bool <span class="cov0" title="0">{
        ch.paused.mu.RLock()
        defer ch.paused.mu.RUnlock()

        return ch.paused.value
}</span>

// IsClosed safely wraps the base channel IsClosed.
func (ch *Channel) IsClosed() bool <span class="cov0" title="0">{
        ch.baseChan.mu.RLock()
        defer ch.baseChan.mu.RUnlock()

        return ch.baseChan.super == nil || ch.baseChan.super.IsClosed()
}</span>

// Close wraps the base channel Close.
func (ch *Channel) Close() error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        var err error

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                // TODO It's advisable to wait for all Confirmations to arrive before
                // calling Channel.Close() or Connection.Close().
                err = ch.baseChan.super.Close()
        }</span>
        <span class="cov0" title="0">ch.opt.cancelCtx()

        return err</span>
}

// Cancel wraps safely the base channel cancellation.
func (ch *Channel) Cancel(consumer string, noWait bool) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.Cancel(consumer, noWait)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// Reject safely wraps the base channel Ack.
func (ch *Channel) Reject(tag uint64, requeue bool) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.Reject(tag, requeue)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// Ack safely wraps the base channel Ack.
func (ch *Channel) Ack(tag uint64, multiple bool) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.Ack(tag, multiple)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// Ack safely wraps the base channel Nak.
func (ch *Channel) Nack(tag uint64, multiple bool, requeue bool) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.Nack(tag, multiple, requeue)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// QueueInspect safely wraps the base channel QueueInspect.
//
// Deprecated: use QueueDeclarePassive
func (ch *Channel) QueueInspect(name string) (amqp.Queue, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.QueueInspect(name)
        }</span>
        <span class="cov0" title="0">return amqp.Queue{}, amqp.ErrClosed</span>
}

// QueueDeclarePassive safely wraps the base channel QueueInspect.
func (ch *Channel) QueueDeclarePassive(name string, durable, autoDelete, exclusive, noWait bool, args amqp.Table) (amqp.Queue, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.QueueDeclarePassive(name, durable, autoDelete, exclusive, noWait, args)
        }</span>
        <span class="cov0" title="0">return amqp.Queue{}, amqp.ErrClosed</span>
}

// PublishWithContext safely wraps the base channel PublishWithContext.
func (ch *Channel) PublishWithContext(ctx context.Context, exchange, key string, mandatory, immediate bool, msg amqp.Publishing) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.PublishWithContext(ctx, exchange, key, mandatory, immediate, msg)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// PublishWithDeferredConfirmWithContext safely wraps the base channel PublishWithDeferredConfirmWithContext.
func (ch *Channel) PublishWithDeferredConfirmWithContext(ctx context.Context, exchange, key string, mandatory, immediate bool, msg amqp.Publishing) (*amqp.DeferredConfirmation, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.PublishWithDeferredConfirmWithContext(ctx, exchange, key, mandatory, immediate, msg)
        }</span>
        <span class="cov0" title="0">return nil, amqp.ErrClosed</span>
}

// QueuePurge safely wraps the base channel QueuePurge.
func (ch *Channel) QueuePurge(name string, noWait bool) (int, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.QueuePurge(name, noWait)
        }</span>
        <span class="cov0" title="0">return 0, amqp.ErrClosed</span>
}

// GetNextPublishSeqNo safely wraps the base channel GetNextPublishSeqNo
func (ch *Channel) GetNextPublishSeqNo() uint64 <span class="cov0" title="0">{
        ch.baseChan.mu.RLock()
        defer ch.baseChan.mu.RUnlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.GetNextPublishSeqNo()
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// QueueDelete safely wraps the base channel QueueDelete.
func (ch *Channel) QueueDelete(name string, ifUnused, ifEmpty, noWait bool) (int, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.QueueDelete(name, ifUnused, ifEmpty, noWait)
        }</span>
        <span class="cov0" title="0">return 0, amqp.ErrClosed</span>
}

// QueueDeclare safely wraps the base channel QueueDeclare.
// Prefer using the [QueueDeclareWithTopology] instead; that also supports bindings, see [TopologyOptions]
func (ch *Channel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args amqp.Table) (amqp.Queue, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.QueueDeclare(name, durable, autoDelete, exclusive, noWait, args)
        }</span>
        <span class="cov0" title="0">return amqp.Queue{}, amqp.ErrClosed</span>
}

// ExchangeDelete safely wraps the base channel ExchangeDelete.
func (ch *Channel) ExchangeDelete(name string, ifUnused, noWait bool) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.ExchangeDelete(name, ifUnused, noWait)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// ExchangeDeclare safely wraps the base channel ExchangeDeclare
// Prefer using the [ExchangeDeclareWithTopology] instead; that also supports bindings, see [TopologyOptions]
func (ch *Channel) ExchangeDeclare(name, kind string, durable, autoDelete, internal, noWait bool, args amqp.Table) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return ch.baseChan.super.ExchangeDeclare(name, kind, durable, autoDelete, internal, noWait, args)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// QueueDeclareWithTopology safely declares a desired queue as described in the parameter;
// see [TopologyOptions]
func (ch *Channel) QueueDeclareWithTopology(t *TopologyOptions) (amqp.Queue, error) <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return declareQueue(ch.baseChan.super, t)
        }</span>
        <span class="cov0" title="0">return amqp.Queue{}, amqp.ErrClosed</span>
}

// ExchangeDeclareWithTopology safely declares a desired exchange as described in the parameter;
// see [TopologyOptions]
func (ch *Channel) ExchangeDeclareWithTopology(t *TopologyOptions) error <span class="cov0" title="0">{
        ch.baseChan.mu.Lock()
        defer ch.baseChan.mu.Unlock()

        if ch.baseChan.super != nil </span><span class="cov0" title="0">{
                return declareExchange(ch.baseChan.super, t)
        }</span>
        <span class="cov0" title="0">return amqp.ErrClosed</span>
}

// Queue returns the active (as indicated by [IsDestination] option in topology options) queue name.
// Useful for finding the server assigned name.
func (ch *Channel) Queue() string <span class="cov0" title="0">{
        ch.baseChan.mu.RLock()
        defer ch.baseChan.mu.RUnlock()

        return ch.queue
}</span>

// Name returns the tag defined originally when creating this channel
func (ch *Channel) Name() string <span class="cov0" title="0">{
        return ch.opt.name
}</span>

// Channel returns the low level library channel for further direct access to its Super() low level channel.
// Use sparingly and prefer using the predefined [Channel] wrapping methods instead.
// Pair usage with the provided full [Lock][UnLock] or read [RLock][RUnlock]
// locking/unlocking mechanisms for safety!
func (ch *Channel) Channel() *SafeBaseChan <span class="cov0" title="0">{
        return &amp;ch.baseChan
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by "stringer -type=ClientType -trimprefix=Cli"; DO NOT EDIT.

package grabbit

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[CliConnection-0]
        _ = x[CliChannel-1]
}

const _ClientType_name = "ConnectionChannel"

var _ClientType_index = [...]uint8{0, 10, 17}

func (i ClientType) String() string <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= ClientType(len(_ClientType_index)-1) </span><span class="cov0" title="0">{
                return "ClientType(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov0" title="0">return _ClientType_name[_ClientType_index[i]:_ClientType_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by "stringer -type=ConfirmationOutcome -linecomment"; DO NOT EDIT.

package grabbit

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[ConfirmationTimeOut-0]
        _ = x[ConfirmationClosed-1]
        _ = x[ConfirmationDisabled-2]
        _ = x[ConfirmationPrevious-3]
        _ = x[ConfirmationACK-4]
        _ = x[ConfirmationNAK-5]
}

const _ConfirmationOutcome_name = "no timely responsedata confirmation channel is closedbase channel has not been put into confirm modelower sequence number than expectedACK (publish confirmed)NAK (publish negative acknowledgement)"

var _ConfirmationOutcome_index = [...]uint8{0, 18, 53, 100, 135, 158, 196}

func (i ConfirmationOutcome) String() string <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= ConfirmationOutcome(len(_ConfirmationOutcome_index)-1) </span><span class="cov0" title="0">{
                return "ConfirmationOutcome(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov0" title="0">return _ConfirmationOutcome_name[_ConfirmationOutcome_index[i]:_ConfirmationOutcome_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package grabbit

import (
        "context"
        "errors"
        "net/url"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

// Connection wraps a [SafeBaseConn] with additional attributes
// (impl. details: rabbit URL, [ConnectionOptions] and a cancelling context).
// Applications should obtain a connection using [NewConnection].
type Connection struct {
        baseConn SafeBaseConn      // supporting amqp connection
        address  string            // where to connect
        blocked  SafeBool          // TCP stream status
        opt      ConnectionOptions // user parameters
}

// NewConnection creates a new managed Connection object with the given address, configuration, and option functions.
//
// Example Usage:
//
//          conn := NewConnection("amqp://guest:guest@localhost:5672/", amqp.Config{},
//                  WithConnectionOptionContext(context.Background(),
//                  WithConnectionOptionName("default"),
//                  WithConnectionOptionDown(Down),
//                  WithConnectionOptionUp(Up),
//                  WithConnectionOptionRecovering(Reattempting),
//                  WithConnectionOptionNotification(connStatusChan),
//          )
//
// Parameters:
//   - address: the address of the connection.
//   - config: the AMQP configuration.
//   - optionFuncs: variadic option functions to customize the connection options.
//
// Returns: a new Connection object.
func NewConnection(address string, config amqp.Config, optionFuncs ...func(*ConnectionOptions)) *Connection <span class="cov4" title="3">{
        opt := ConnectionOptions{
                notifier: make(chan Event),
                name:     "default",
                delayer:  DefaultDelayer{Value: 7500 * time.Millisecond},
                ctx:      context.Background(),
        }

        for _, optionFunc := range optionFuncs </span><span class="cov10" title="16">{
                optionFunc(&amp;opt)
        }</span>

        <span class="cov4" title="3">conn := &amp;Connection{
                baseConn: SafeBaseConn{},
                address:  address,
                opt:      opt,
        }

        conn.opt.ctx, conn.opt.cancelCtx = context.WithCancel(opt.ctx)

        go func() </span><span class="cov4" title="3">{
                if !conn.reconnectLoop(config) </span><span class="cov1" title="1">{
                        return
                }</span>
                <span class="cov3" title="2">conn.manage(config)</span>
        }()

        <span class="cov4" title="3">return conn</span>
}

// setFlow updates the flow control status of the Connection.
//
// It takes a value of type amqp.Blocking as a parameter and updates the
// blocked status of the Connection accordingly. If the value is active, the
// Connection is considered blocked and an EventBlocked event is raised. If
// the value is inactive, the Connection is considered unblocked and an
// EventUnBlocked event is raised.
//
// The function also sets the SourceType to CliConnection, the SourceName to
// the name of the Connection, the Kind to the appropriate EventType based on
// the value, and the Err to a SomeErrFromString value created from the reason
// provided in the value parameter.
//
// The function does not return anything.
func (conn *Connection) setFlow(value amqp.Blocking) <span class="cov0" title="0">{
        conn.blocked.mu.Lock()
        conn.blocked.value = value.Active
        conn.blocked.mu.Unlock()

        var kind EventType
        if value.Active </span><span class="cov0" title="0">{
                kind = EventBlocked
        }</span> else<span class="cov0" title="0"> {
                kind = EventUnBlocked
        }</span>

        <span class="cov0" title="0">Event{
                SourceType: CliConnection,
                SourceName: conn.opt.name,
                Kind:       kind,
                Err:        SomeErrFromString(value.Reason),
        }.raise(conn.opt.notifier)</span>
}

// refreshCredentials refreshes the credentials of the Connection.
// If the credentials field of the Connection object is not nil it retrieves the password from the credentials object and
// updates the address field of the Connection object with the username included in the URL and the password.
//
// No parameters.
// No return type.
func (conn *Connection) refreshCredentials() <span class="cov5" title="4">{
        if conn.opt.credentials != nil </span><span class="cov0" title="0">{
                if secret, err := conn.opt.credentials.Password(); err == nil </span><span class="cov0" title="0">{
                        if u, err := url.Parse(conn.address); err == nil </span><span class="cov0" title="0">{
                                u.User = url.UserPassword(u.User.Username(), secret)
                                conn.address = u.String()
                        }</span>
                }
        }
}

// notificationChannels returns the notification channels for the Connection.
//
// It acquires a lock on the baseConn mutex and releases it when done. If the baseConn.super is not nil,
// it creates and returns two channels: evtClosed for notifying on connection close, and evtBlocked for notifying on connection blockage.
// If the baseConn.super is nil, it returns nil for both channels and an error indicating that the connection is not yet available.
//
// Returns:
//   - chan *amqp.Error: A channel for notifying on connection close.
//   - chan amqp.Blocking: A channel for notifying on connection blockage.
//   - error: An error indicating that the connection is not yet available.
func (conn *Connection) notificationChannels() (chan *amqp.Error, chan amqp.Blocking, error) <span class="cov3" title="2">{
        conn.baseConn.mu.Lock()
        defer conn.baseConn.mu.Unlock()

        if conn.baseConn.super != nil </span><span class="cov3" title="2">{
                evtClosed := conn.baseConn.super.NotifyClose(make(chan *amqp.Error))
                evtBlocked := conn.baseConn.super.NotifyBlocked(make(chan amqp.Blocking)) // TODO: is this persistent (similar to chan.Flow?)
                return evtClosed, evtBlocked, nil
        }</span>

        <span class="cov0" title="0">return nil, nil, errors.New("connection not yet available")</span>
}

// manage is a function that manages the connection state.
//
// It takes a config parameter of type amqp.Config.
// This function does not return anything.
func (conn *Connection) manage(config amqp.Config) <span class="cov3" title="2">{
        for </span><span class="cov3" title="2">{
                evtClosed, evtBlocked, err := conn.notificationChannels()
                if err != nil </span><span class="cov0" title="0">{
                        // FIXME adopt a circuit breaker policy
                        time.Sleep(conn.opt.delayer.Delay(3))
                        continue</span>
                }

                <span class="cov3" title="2">select </span>{
                case &lt;-conn.opt.ctx.Done():<span class="cov1" title="1">
                        conn.Close() // cancelCtx() called again but idempotent
                        return</span>
                case status := &lt;-evtBlocked:<span class="cov0" title="0">
                        conn.setFlow(status)</span>
                case err, notifierStatus := &lt;-evtClosed:<span class="cov1" title="1">
                        if !conn.recover(config, SomeErrFromError(err, err != nil), notifierStatus) </span><span class="cov1" title="1">{
                                return
                        }</span>
                }
        }
}

// recover recovers the connection with the specified configuration after an error occurs.
//
// It raises an event to notify the notifier about the connection going down and checks if the
// callback is allowed to handle the connection going down. If the notifier status is false, it
// resets the base connection and raises an event to notify the notifier about the connection
// being closed. Finally, it checks if the error is set and starts the reconnection loop.
//
// Parameters:
//   - config: the AMQP configuration to reconnect with.
//   - err: an optional error that occurred during the connection.
//   - notifierStatus: a boolean indicating whether the notifier is active.
//
// Returns:
//   - a boolean indicating if the recovery was successful.
func (conn *Connection) recover(config amqp.Config, err OptionalError, notifierStatus bool) bool <span class="cov1" title="1">{
        Event{
                SourceType: CliConnection,
                SourceName: conn.opt.name,
                Kind:       EventDown,
                Err:        err,
        }.raise(conn.opt.notifier)

        if !callbackAllowedDown(conn.opt.cbDown, conn.opt.name, err) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov1" title="1">if !notifierStatus </span><span class="cov1" title="1">{
                conn.baseConn.reset()

                Event{
                        SourceType: CliConnection,
                        SourceName: conn.opt.name,
                        Kind:       EventClosed,
                }.raise(conn.opt.notifier)
        }</span>
        // no err means gracefully closed on demand
        <span class="cov1" title="1">return err.IsSet() &amp;&amp; conn.reconnectLoop(config)</span>
}

// rebase establishes a new base connection to the AMQP server using the given configuration.
//
// The function takes a `config` parameter of type `amqp.Config` which
// specifies the configuration options for the connection.
//
// It returns a boolean value indicating whether the connection was
// successfully established.
func (conn *Connection) rebase(config amqp.Config) bool <span class="cov5" title="4">{
        result := true
        kind := EventUp
        optError := OptionalError{}

        conn.refreshCredentials()

        if super, err := amqp.DialConfig(conn.address, config); err != nil </span><span class="cov3" title="2">{
                optError = SomeErrFromError(err, true)
                kind = EventCannotEstablish
                result = false
        }</span> else<span class="cov3" title="2"> {
                conn.baseConn.set(super)
        }</span>

        <span class="cov5" title="4">Event{
                SourceType: CliConnection,
                SourceName: conn.opt.name,
                Kind:       kind,
                Err:        optError,
        }.raise(conn.opt.notifier)
        callbackDoUp(result, conn.opt.cbUp, conn.opt.name)

        return result</span>
}

// reconnectLoop is a function that handles the reconnection process for the Connection struct.
//
// It takes in a config parameter of type amqp.Config.
// It returns a boolean value indicating whether the reconnection was successful or not.
// If a callback function callbackAllowedRecovery returns false or a delayer function delayerCompleted returns false, it returns false.
func (conn *Connection) reconnectLoop(config amqp.Config) bool <span class="cov4" title="3">{
        retry := 0
        for </span><span class="cov6" title="5">{
                retry = (retry + 1) % 0xFFFF
                if !callbackAllowedRecovery(conn.opt.cbReconnect, conn.opt.name, retry) </span><span class="cov1" title="1">{
                        return false
                }</span>

                <span class="cov5" title="4">if conn.rebase(config) </span><span class="cov3" title="2">{
                        return true
                }</span>
                <span class="cov3" title="2">if !delayerCompleted(conn.opt.ctx, conn.opt.delayer, retry) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package grabbit

import (
        "context"
)

// ConnectionOptions defines a collection of attributes used internally
// by the [Connection].
//
// Attributes can be set via optionFuncs parameters of [NewConnection]
// via WithConnectionOption&lt;Fct&gt; family, ex:
// [WithConnectionOptionDown], [WithConnectionOptionContext], [WithConnectionOptionNotification].
type ConnectionOptions struct {
        notifier    chan Event             // status events feedback channel
        name        string                 // tag for this connection
        credentials SecretProvider         // value for UpdateSecret()
        delayer     DelayProvider          // how much to wait between re-attempts
        cbDown      CallbackWhenDown       // callback on conn lost
        cbUp        CallbackWhenUp         // callback when conn recovered
        cbReconnect CallbackWhenRecovering // callback when recovering
        ctx         context.Context        // cancellation context
        cancelCtx   context.CancelFunc     // aborts the reconnect loop
}

// WithConnectionOptionDown stores the application space callback for
// connection down events.
func WithConnectionOptionDown(down CallbackWhenDown) func(options *ConnectionOptions) <span class="cov10" title="3">{
        return func(options *ConnectionOptions) </span><span class="cov10" title="3">{
                options.cbDown = down
        }</span>
}

// WithConnectionOptionUp stores the application space callback for
// connection established events.
func WithConnectionOptionUp(up CallbackWhenUp) func(options *ConnectionOptions) <span class="cov10" title="3">{
        return func(options *ConnectionOptions) </span><span class="cov10" title="3">{
                options.cbUp = up
        }</span>
}

// WithConnectionOptionRecovering stores the application space callback for
// connection recovering events.
func WithConnectionOptionRecovering(recover CallbackWhenRecovering) func(options *ConnectionOptions) <span class="cov10" title="3">{
        return func(options *ConnectionOptions) </span><span class="cov10" title="3">{
                options.cbReconnect = recover
        }</span>
}

// WithConnectionOptionContext stores the application provided context.
// Cancelling this context will terminate the recovery loop and also close down the
// connection (and indirectly its channel dependents).
func WithConnectionOptionContext(ctx context.Context) func(options *ConnectionOptions) <span class="cov10" title="3">{
        return func(options *ConnectionOptions) </span><span class="cov10" title="3">{
                options.ctx = ctx
        }</span>
}

// WithConnectionOptionPassword provides password refresh capabilities
// for dynamically protected services (future IAM)
func WithConnectionOptionPassword(credentials SecretProvider) func(options *ConnectionOptions) <span class="cov0" title="0">{
        return func(options *ConnectionOptions) </span><span class="cov0" title="0">{
                options.credentials = credentials
        }</span>
}

// WithConnectionOptionDelay provides an application space defined
// delay (between re-connection attempts) policy. An example of
// [DelayProvider] could be an exponential timeout routine based on the
// retry parameter.
func WithConnectionOptionDelay(delayer DelayProvider) func(options *ConnectionOptions) <span class="cov0" title="0">{
        return func(options *ConnectionOptions) </span><span class="cov0" title="0">{
                options.delayer = delayer
        }</span>
}

// WithConnectionOptionName assigns a tag to this connection.
func WithConnectionOptionName(name string) func(options *ConnectionOptions) <span class="cov10" title="3">{
        return func(options *ConnectionOptions) </span><span class="cov10" title="3">{
                options.name = name
        }</span>
}

// WithConnectionOptionNotification provides an application defined
// [Event] receiver to handle various alerts about the connection status.
func WithConnectionOptionNotification(ch chan Event) func(options *ConnectionOptions) <span class="cov1" title="1">{
        return func(options *ConnectionOptions) </span><span class="cov1" title="1">{
                options.notifier = ch
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package grabbit

import (
        "sync"

        amqp "github.com/rabbitmq/amqp091-go"
)

// SafeBaseConn wraps in a concurrency safe way the low level amqp.Connection.
type SafeBaseConn struct {
        super *amqp.Connection // core connection
        mu    sync.RWMutex     // makes this concurrent safe, maintenance wise only!
}

// IsSet tests if the low level amqp connection is set.
func (c *SafeBaseConn) IsSet() bool <span class="cov6" title="2">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return c.super != nil
}</span>

// Super returns the low level amqp connection for direct interactions.
// Use sparingly and prefer using the predefined [Connection] wrapping methods instead.
// Pair usage with the locking/unlocking routines for safety!
func (c *SafeBaseConn) Super() *amqp.Connection <span class="cov0" title="0">{
        return c.super
}</span>

// Lock acquires locking of the low level connection [Super] for amqp operations.
// Use sparingly and fast as this locks-out the channel recovery!
func (c *SafeBaseConn) Lock() <span class="cov0" title="0">{
        c.mu.Lock()
}</span>

// UnLock releases the low level connection [Super] lock.
func (c *SafeBaseConn) UnLock() <span class="cov0" title="0">{
        c.mu.Unlock()
}</span>

// set is a private method for updating the super connection (post recovery)
func (c *SafeBaseConn) set(super *amqp.Connection) <span class="cov10" title="3">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.super = super
}</span>

// reset is a private method for removing the current super connection (pre-recovery)
func (c *SafeBaseConn) reset() <span class="cov1" title="1">{
        c.set(nil)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package grabbit

import (
        amqp "github.com/rabbitmq/amqp091-go"
)

// IsBlocked returns the TCP flow status of the base connection.
func (conn *Connection) IsBlocked() bool <span class="cov0" title="0">{
        conn.blocked.mu.RLock()
        defer conn.blocked.mu.RUnlock()

        return conn.blocked.value
}</span>

// IsClosed safely wraps the amqp connection IsClosed
func (conn *Connection) IsClosed() bool <span class="cov8" title="6">{
        conn.baseConn.mu.RLock()
        defer conn.baseConn.mu.RUnlock()

        return conn.baseConn.super == nil || conn.baseConn.super.IsClosed()
}</span>

// Close safely wraps the amqp connection Close and terminates the maintenance loop.
func (conn *Connection) Close() error <span class="cov10" title="8">{
        conn.baseConn.mu.Lock()
        defer conn.baseConn.mu.Unlock()

        var err error

        if conn.baseConn.super != nil </span><span class="cov4" title="2">{
                err = conn.baseConn.super.Close()
        }</span>
        <span class="cov10" title="8">conn.baseConn.super = nil
        conn.opt.cancelCtx()

        return err</span>
}

// Channel safely wraps the amqp connection Channel() function.
func (conn *Connection) Channel() (*amqp.Channel, error) <span class="cov0" title="0">{
        conn.baseConn.mu.Lock()
        defer conn.baseConn.mu.Unlock()

        if conn.baseConn.super != nil </span><span class="cov0" title="0">{
                return conn.baseConn.super.Channel()
        }</span>

        <span class="cov0" title="0">return nil, amqp.ErrClosed</span>
}

// Connection returns the safe base connection and thus indirectly the low level library connection.
func (conn *Connection) Connection() *SafeBaseConn <span class="cov4" title="2">{
        return &amp;conn.baseConn
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package grabbit

import (
        "time"
)

// defaultPayloadProcessor processes the payload using default logic.
//
// It takes the following parameters:
//   - props: a pointer to DeliveriesProperties struct
//   - messages: a slice of DeliveryData structs
//   - mustAck: a boolean indicating whether the messages must be acknowledged
//   - ch: a pointer to Channel struct
//
// It does not return any value.
func defaultPayloadProcessor(props *DeliveriesProperties, messages []DeliveryData, mustAck bool, ch *Channel) <span class="cov0" title="0">{
        Event{
                SourceType: CliChannel,
                SourceName: props.ConsumerTag,
                Kind:       EventMessageReceived,
                Err:        SomeErrFromString("default processor discards messages"),
        }.raise(ch.opt.notifier)

        if mustAck &amp;&amp; len(messages) != 0 </span><span class="cov0" title="0">{
                ch.Ack(messages[len(messages)-1].DeliveryTag, true)
        }</span>
}

// Consumer implements an object allowing calling applications
// to receive messages on already established connections.
// Create a consumer instance by calling [NewConsumer].
type Consumer struct {
        channel *Channel        // assigned channel
        opt     ConsumerOptions // specific options
}

// Channel returns the managed [Channel] which can be further used to extract [SafeBaseChan]
func (p *Consumer) Channel() *Channel <span class="cov0" title="0">{
        return p.channel
}</span>

// Cancel wraps safely the base consumer channel cancellation.
func (p *Consumer) Cancel() error <span class="cov0" title="0">{
        // false indicates future intention (i.e. process already retrieved)
        return p.channel.Cancel(p.opt.ConsumerName, false)
}</span>

// NewConsumer creates a consumer with the desired options and then starts consuming.
// It creates and opens a new dedicated [Channel] using the passed shared connection.
// NOTE: It's advisable to use separate connections for Channel.Publish and Channel.Consume
func NewConsumer(conn *Connection, opt ConsumerOptions, optionFuncs ...func(*ChannelOptions)) *Consumer <span class="cov0" title="0">{
        useParams := ChanUsageParameters{
                ConsumerUsageOptions: opt.ConsumerUsageOptions,
        }
        chanOpt := append(optionFuncs, WithChannelOptionUsageParams(useParams))

        return &amp;Consumer{
                channel: NewChannel(conn, chanOpt...),
                opt:     opt,
        }
}</span>

// Available returns the status of both the underlying connection and channel.
func (c *Consumer) Available() (bool, bool) <span class="cov0" title="0">{
        return !c.channel.conn.IsClosed(), !c.channel.IsClosed()
}</span>

// AwaitAvailable waits till the consumer infrastructure is ready or timeout expires.
// Useful when the connections and channels are about being created or recovering.
// When passing zero value parameter the defaults used are 7500ms for timeout and
// 330 ms for polling frequency.
func (c *Consumer) AwaitAvailable(timeout, pollFreq time.Duration) bool <span class="cov0" title="0">{
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 7500 * time.Millisecond
        }</span>
        <span class="cov0" title="0">if pollFreq == 0 </span><span class="cov0" title="0">{
                pollFreq = 330 * time.Millisecond
        }</span>

        // status polling
        <span class="cov0" title="0">ticker := time.NewTicker(pollFreq)
        defer ticker.Stop()
        done := make(chan bool)

        // session timeout
        go func() </span><span class="cov0" title="0">{
                time.Sleep(timeout)
                done &lt;- true
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        return false</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if connUp, chanUp := c.Available(); connUp &amp;&amp; chanUp </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
}

// Close shuts down cleanly the publisher channel.
func (c *Consumer) Close() error <span class="cov0" title="0">{
        return c.channel.Close()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package grabbit

import (
        "crypto/rand"
        "encoding/hex"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

// ConsumerUsageOptions defines parameters for driving the consumers
// behavior and indicating to the supporting channel to start consuming.
type ConsumerUsageOptions struct {
        IsConsumer        bool          // indicates if this chan is used for consuming
        ConsumerName      string        // chanel wide consumers unique identifier
        PrefetchTimeout   time.Duration // how long to wait for PrefetchCount messages to arrive
        PrefetchCount     int           // Qos count
        PrefetchSize      int           // Qos payload size
        QosGlobal         bool          // all future channels
        ConsumerQueue     string        // queue name from which to receive. Overridden by engine assigned name.
        ConsumerAutoAck   bool          // see [amqp.Consume]
        ConsumerExclusive bool          // see [amqp.Consume]
        ConsumerNoLocal   bool          // see [amqp.Consume]
        ConsumerNoWait    bool          // see [amqp.Consume]
        ConsumerArgs      amqp.Table    // core properties
}

type ConsumerOptions struct {
        ConsumerUsageOptions
}

// RandConsumerName creates a random string for the consumers.
// It is used internally by DefaultConsumerOptions by setting the
// 'ConsumerName' property of [ConsumerOptions]
func RandConsumerName() string <span class="cov0" title="0">{
        randBytes := make([]byte, 8)
        rand.Read(randBytes)
        return hex.EncodeToString(randBytes)
}</span>

// DefaultConsumerOptions creates some sane defaults for consuming messages.
func DefaultConsumerOptions() ConsumerOptions <span class="cov0" title="0">{
        return ConsumerOptions{
                ConsumerUsageOptions: ConsumerUsageOptions{
                        IsConsumer:    true,
                        PrefetchCount: 1,
                        PrefetchSize:  0,
                        // enforce it, otherwise we lose track of server assigned value and
                        // cannot cancel consumer afterwards
                        ConsumerName: RandConsumerName(),
                },
        }
}</span>

// WithName sets the name of the ConsumerOptions.
//
// name: the name to set for the ConsumerOptions.
// return: the updated ConsumerOptions.
func (opt *ConsumerOptions) WithName(name string) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerName = name
        return opt
}</span>

// WithPrefetchTimeout sets the prefetch timeout for the ConsumerOptions struct.
//
// timeout - The duration of the prefetch timeout.
// Returns the updated ConsumerOptions struct.
func (opt *ConsumerOptions) WithPrefetchTimeout(timeout time.Duration) *ConsumerOptions <span class="cov0" title="0">{
        opt.PrefetchTimeout = timeout
        return opt
}</span>

// WithPrefetchCount sets the prefetch count for the ConsumerOptions.
//
// count: the number of messages to prefetch.
// returns: a pointer to the updated ConsumerOptions.
func (opt *ConsumerOptions) WithPrefetchCount(count int) *ConsumerOptions <span class="cov0" title="0">{
        opt.PrefetchCount = count
        return opt
}</span>

// WithPrefetchSize sets the prefetch size for the ConsumerOptions struct.
//
// It takes an integer `size` as a parameter and sets the PrefetchSize field of the ConsumerOptions struct to that value.
// It returns a pointer to the modified ConsumerOptions struct.
func (opt *ConsumerOptions) WithPrefetchSize(size int) *ConsumerOptions <span class="cov0" title="0">{
        opt.PrefetchSize = size
        return opt
}</span>

// WithQosGlobal sets the global QoS option for the ConsumerOptions struct.
//
// It takes a boolean value, `global`, to determine whether the QoS option should be set globally.
// The function returns a pointer to the updated ConsumerOptions struct.
func (opt *ConsumerOptions) WithQosGlobal(global bool) *ConsumerOptions <span class="cov0" title="0">{
        opt.QosGlobal = global
        return opt
}</span>

// WithQueue sets the consumer queue for the ConsumerOptions struct.
//
// queue: the name of the queue.
// returns: the updated ConsumerOptions struct.
func (opt *ConsumerOptions) WithQueue(queue string) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerQueue = queue
        return opt
}</span>

// WithAutoAck sets the ConsumerAutoAck field of the ConsumerOptions struct
// to the provided boolean value.
//
// autoAck: A boolean value indicating whether the consumer should automatically
// acknowledge messages.
//
// *ConsumerOptions: A pointer to the ConsumerOptions struct.
// Returns: A pointer to the updated ConsumerOptions struct.
func (opt *ConsumerOptions) WithAutoAck(autoAck bool) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerAutoAck = autoAck
        return opt
}</span>

// WithExclusive sets the exclusive flag for the ConsumerOptions.
//
// exclusive: a boolean indicating whether the ConsumerOptions should be exclusive.
// Returns a pointer to the updated ConsumerOptions.
func (opt *ConsumerOptions) WithExclusive(exclusive bool) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerExclusive = exclusive
        return opt
}</span>

// WithNoLocal sets the ConsumerNoLocal field of the ConsumerOptions struct.
//
// It takes a boolean parameter named noLocal.
// It returns a pointer to the ConsumerOptions struct.
func (opt *ConsumerOptions) WithNoLocal(noLocal bool) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerNoLocal = noLocal
        return opt
}</span>

// WithNoWait sets the ConsumerNoWait field of ConsumerOptions struct and returns the modified ConsumerOptions object.
//
// Parameters:
// - noWait: a boolean value indicating whether the consumer should wait or not.
//
// Return type:
// - *ConsumerOptions: the modified ConsumerOptions object.
func (opt *ConsumerOptions) WithNoWait(noWait bool) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerNoWait = noWait
        return opt
}</span>

// WithArgs sets the arguments for the consumer options.
//
// args: The arguments to be set.
// Returns: The updated consumer options.
func (opt *ConsumerOptions) WithArgs(args amqp.Table) *ConsumerOptions <span class="cov0" title="0">{
        opt.ConsumerArgs = args
        return opt
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package grabbit

import (
        "errors"
)

type OptionalError struct {
        err   error
        isSet bool
}

// SomeErrFromError creates an OptionalError struct with the given error and isSet values.
//
// Parameters:
// - err: The error to be assigned to the OptionalError struct.
// - isSet: A boolean value indicating whether the error is set or not.
//
// Return:
// - OptionalError: The OptionalError struct with the assigned error and isSet values.
func SomeErrFromError(err error, isSet bool) OptionalError <span class="cov10" title="3">{
        return OptionalError{
                // dereferencing an interface always gets us a valid address.
                // nil testing of this pointer won't work
                err:   err,
                isSet: isSet,
        }
}</span>

// SomeErrFromString creates an OptionalError from the specified text.
//
// Parameters:
// - text: the string to create the error from.
//
// Return type:
// - OptionalError: the created OptionalError.
func SomeErrFromString(text string) OptionalError <span class="cov0" title="0">{
        err := errors.New(text)
        return OptionalError{
                err:   err,
                isSet: true,
        }
}</span>

// Or returns the optional error if it is set, otherwise it returns the provided error.
//
// err - The error to return if the optional error is not set.
// error - The optional error.
func (e OptionalError) Or(err error) error <span class="cov0" title="0">{
        if e.isSet </span><span class="cov0" title="0">{
                return e.err
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Error returns the error string representation of the OptionalError.
//
// It calls the Or method on the OptionalError to get the error value and returns its
// Error method.
func (e OptionalError) Error() string <span class="cov0" title="0">{
        err := e.Or(errors.New("no error"))
        return err.Error()
}</span>

// IsSet returns a boolean value indicating whether the OptionalError is set.
//
// This function does not take any parameters.
// It returns a boolean value.
func (e OptionalError) IsSet() bool <span class="cov1" title="1">{
        return e.isSet
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package grabbit

import (
        "sync"
)

// SafeBool wraps a boolean in a concurrency safe way so it can
// be set, reset and tested from different coroutines.
type SafeBool struct {
        value bool
        mu    sync.RWMutex
}

// ClientType defines the class of objects that interact with the amqp functionality.
// Used mostly for sending alerts about specific functionality areas.
type ClientType int

//go:generate stringer -type=ClientType -trimprefix=Cli
const (
        CliConnection ClientType = iota
        CliChannel
)

// EventType defines the class of alerts sent to the application layer.
type EventType int

//go:generate stringer -type=EventType -trimprefix=Event
const (
        EventUp EventType = iota
        EventDown
        EventCannotEstablish
        EventBlocked
        EventUnBlocked
        EventClosed
        EventMessageReceived
        EventMessagePublished
        EventMessageReturned
        EventConfirm
        EventQos
        EventConsume
        EventDefineTopology
        EventDataExhausted
        EventDataPartial
)

// Event defines a simple body structure for the alerts received
// via the notification channels passed in [WithChannelOptionNotification]
// and [WithConnectionOptionNotification].
type Event struct {
        SourceType ClientType    // origin type
        SourceName string        // origin tag
        TargetName string        // affected tag
        Kind       EventType     // type of event
        Err        OptionalError // low level error
}

// raise pushes an event type from a particular connection or channel
// over the provided notification channel. If the notification channel does not have enough capacity,
// it ignores the event and does nothing.
//
// See WithChannelOptionNotification and WithConnectionOptionNotification
func (event Event) raise(ch chan Event) <span class="cov10" title="6">{
        select </span>{
        case ch &lt;- event:<span class="cov9" title="5"></span>
        default:<span class="cov1" title="1"></span>
                // chan has not enough capacity, dump this alert
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by "stringer -type=EventType -trimprefix=Event"; DO NOT EDIT.

package grabbit

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[EventUp-0]
        _ = x[EventDown-1]
        _ = x[EventCannotEstablish-2]
        _ = x[EventBlocked-3]
        _ = x[EventUnBlocked-4]
        _ = x[EventClosed-5]
        _ = x[EventMessageReceived-6]
        _ = x[EventMessagePublished-7]
        _ = x[EventMessageReturned-8]
        _ = x[EventConfirm-9]
        _ = x[EventQos-10]
        _ = x[EventConsume-11]
        _ = x[EventDefineTopology-12]
        _ = x[EventDataExhausted-13]
        _ = x[EventDataPartial-14]
}

const _EventType_name = "UpDownCannotEstablishBlockedUnBlockedClosedMessageReceivedMessagePublishedMessageReturnedConfirmQosConsumeDefineTopologyDataExhaustedDataPartial"

var _EventType_index = [...]uint8{0, 2, 6, 21, 28, 37, 43, 58, 74, 89, 96, 99, 106, 120, 133, 144}

func (i EventType) String() string <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= EventType(len(_EventType_index)-1) </span><span class="cov0" title="0">{
                return "EventType(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov0" title="0">return _EventType_name[_EventType_index[i]:_EventType_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package grabbit

import (
        "context"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

// SecretProvider allows passing a bespoke method for providing the
// secret required when connecting to the Rabbit engine.
// See [WithConnectionOptionPassword].
type SecretProvider interface {
        Password() (string, error)
}

// DelayProvider allows passing a bespoke method for providing the
// delay policy for waiting between reconnection attempts.
// See [WithConnectionOptionDelay], [WithChannelOptionDelay]. TIP:
// one could pass en exponential delayer derived from the 'retry' counter.
type DelayProvider interface {
        Delay(retry int) time.Duration
}

// DefaultDelayer allows defining a basic (constant) delay policy.
// The implementation defaults used by new connections and channels
// has a value of 7.5 seconds.
type DefaultDelayer struct {
        Value time.Duration
}

// Delay implements the DelayProvider i/face for the DefaultDelayer.
func (delayer DefaultDelayer) Delay(retry int) time.Duration <span class="cov4" title="2">{
        return delayer.Value
}</span>

// CallbackWhenDown defines a function type used when connection was lost.
// Returns false when want aborting this connection.
// Pass your implementations via [WithChannelOptionDown] and [WithConnectionOptionDown].
type CallbackWhenDown func(name string, err OptionalError) bool

// CallbackWhenUp defines a function type used after a successful connection or channel recovery.
// Applications can define their own handler and pass it via
// [WithConnectionOptionUp] and [WithChannelOptionUp].
type CallbackWhenUp func(name string)

// CallbackNotifyPublish defines a function type for handling the publish notifications.
// Applications can define their own handler and pass it via [WithChannelOptionNotifyPublish].
type CallbackNotifyPublish func(confirm amqp.Confirmation, ch *Channel)

// CallbackNotifyReturn defines a function type for handling the return notifications.
// Applications can define their own handler and pass it via [WithChannelOptionNotifyReturn].
type CallbackNotifyReturn func(confirm amqp.Return, ch *Channel)

// DeliveriesProperties captures the common attributes of multiple commonly grouped
// (i.e. received over same channel in one go) deliveries. It is an incomplete [amqp.Delivery]
type DeliveriesProperties struct {
        Headers amqp.Table // Application or header exchange table
        // Properties; assume all are common
        ContentType     string // MIME content type
        ContentEncoding string // MIME content encoding
        DeliveryMode    uint8  // queue implementation use - non-persistent (1) or persistent (2)
        Priority        uint8  // queue implementation use - 0 to 9
        ConsumerTag     string // client tag as provided during consumer registration
        Exchange        string // basic.publish exchange
        RoutingKey      string // basic.publish routing key
}

// DeliveryPropsFrom generates a DeliveriesProperties struct from an amqp.Delivery.
//
// Takes a pointer to an amqp.Delivery as the parameter and returns a DeliveriesProperties struct.
func DeliveryPropsFrom(d *amqp.Delivery) (prop DeliveriesProperties) <span class="cov0" title="0">{
        return DeliveriesProperties{
                Headers:         d.Headers,
                ContentType:     d.ContentType,
                ContentEncoding: d.ContentEncoding,
                DeliveryMode:    d.DeliveryMode,
                Priority:        d.Priority,
                ConsumerTag:     d.ConsumerTag,
                Exchange:        d.Exchange,
                RoutingKey:      d.RoutingKey,
        }
}</span>

// DeliveryPayload subtypes the actual content of deliveries
type DeliveryPayload []byte

// DeliveryData isolates the data part of each specific delivered message
type DeliveryData struct {
        Body        DeliveryPayload // actual data payload
        DeliveryTag uint64          // sequential number of this message
        Redelivered bool            // message has been re-enqueued
        Expiration  string          // message expiration spec
        MessageId   string          // message identifier
        Timestamp   time.Time       // message timestamp
        Type        string          // message type name
        UserId      string          // user of the publishing connection
        AppId       string          // application id
}

// DeliveryDataFrom creates a DeliveryData object from an amqp.Delivery object.
//
// It takes a pointer to an amqp.Delivery object as its parameter and returns a DeliveryData object.
func DeliveryDataFrom(d *amqp.Delivery) (data DeliveryData) <span class="cov0" title="0">{
        return DeliveryData{
                Body:        d.Body,
                DeliveryTag: d.DeliveryTag,
                Redelivered: d.Redelivered,
                Expiration:  d.Expiration,
                MessageId:   d.MessageId,
                Timestamp:   d.Timestamp,
                Type:        d.Type,
                UserId:      d.UserId,
                AppId:       d.AppId,
        }
}</span>

// CallbackProcessMessages defines a user passed function for processing the received messages.
// Applications can define their own handler and pass it via [WithChannelOptionProcessor].
type CallbackProcessMessages func(props *DeliveriesProperties, messages []DeliveryData, mustAck bool, ch *Channel)

// CallbackWhenRecovering defines a function used prior to recovering a connection.
// Returns false when want aborting this connection.
// Applications can define their own handler and pass it via
// [WithChannelOptionRecovering] and [WithConnectionOptionRecovering].
type CallbackWhenRecovering func(name string, retry int) bool

// callbackAllowedRecovery performs the user test
// (when provided via WithConnectionOptionRecovering, WithChannelOptionRecovering)
// for allowing the recovery process. Returning 'false' will break out the reconnecting loop
// (impl.details chanReconnectLoop, connReconnectLoop).
func callbackAllowedRecovery(cb CallbackWhenRecovering, name string, attempt int) bool <span class="cov10" title="5">{
        return cb == nil || cb(name, attempt)
}</span>

// callbackAllowedDown performs the user test
// (when provided via [WithChannelOptionDown], [WithConnectionOptionDown])
// for allowing continuing to the recovery process. Returning 'false' will break out the reconnecting loop
// (impl.details connRecover, chanRecover).
func callbackAllowedDown(cb CallbackWhenDown, name string, err OptionalError) bool <span class="cov1" title="1">{
        return cb == nil || cb(name, err)
}</span>

// callbackDoUp performs the user action (when provided via WithChannelOptionUp, WithConnectionOptionUp)
// as part of completion of a new connection (chanReconnectLoop-&gt;chanGetNew) or
// channel (chanReconnectLoop-&gt;chanGetNew).
func callbackDoUp(want bool, cb CallbackWhenUp, name string) <span class="cov8" title="4">{
        if want &amp;&amp; cb != nil </span><span class="cov4" title="2">{
                cb(name)
        }</span>
}

// delayerCompleted waits for the provided (WithConnectionOptionDelay, WithChannelOptionDelay)
// or default (DefaultDelayer) timing-out policy to complete as part of the recovery loop
// (see chanReconnectLoop, connReconnectLoop).
func delayerCompleted(ctx context.Context, delayer DelayProvider, attempt int) bool <span class="cov4" title="2">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return false</span>
        case &lt;-time.After(delayer.Delay(attempt)):<span class="cov4" title="2"></span>
        }

        <span class="cov4" title="2">return true</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package grabbit

import (
        "fmt"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

type ConfirmationOutcome int

//go:generate stringer -type=ConfirmationOutcome  -linecomment
const (
        ConfirmationTimeOut  ConfirmationOutcome = iota // no timely response
        ConfirmationClosed                              // data confirmation channel is closed
        ConfirmationDisabled                            // base channel has not been put into confirm mode
        ConfirmationPrevious                            // lower sequence number than expected
        ConfirmationACK                                 // ACK (publish confirmed)
        ConfirmationNAK                                 // NAK (publish negative acknowledgement)
)

// DeferredConfirmation wraps [amqp.DeferredConfirmation] with additional data.
// It inherits (by embedding) all original fields and functonality from the amqp object.
type DeferredConfirmation struct {
        *amqp.DeferredConfirmation                     // wrapped low level confirmation
        Outcome                    ConfirmationOutcome // acknowledgment received stats
        RequestSequence            uint64              // sequence of the original request (GetNextPublishSeqNo)
        ChannelName                string              // channel name of the publisher
        Queue                      string              // queue name of the publisher
}

// Publisher implements an object allowing calling applications
// to publish messages on already established connections.
// Create a publisher instance by calling [NewPublisher].
type Publisher struct {
        channel *Channel         // assigned channel
        opt     PublisherOptions // specific options
}

// defaultNotifyPublish provides a base implementation of [CallbackNotifyPublish] which can be
// overwritten with [WithChannelOptionNotifyPublish]. If confirm.Ack is false
// it sends an [EventMessagePublished] kind of event over the notification channel
// (see [WithChannelOptionNotification]) with a literal error containing the delivery tag.
func defaultNotifyPublish(confirm amqp.Confirmation, ch *Channel) <span class="cov0" title="0">{
        if !confirm.Ack </span><span class="cov0" title="0">{
                Event{
                        SourceType: CliChannel,
                        SourceName: ch.opt.name,
                        Kind:       EventMessagePublished,
                        Err: SomeErrFromString(
                                fmt.Sprintf("delivery tag %d unconfirmed", confirm.DeliveryTag),
                        ),
                }.raise(ch.opt.notifier)
        }</span>
}

// defaultNotifyReturn provides a base implementation of [CallbackNotifyReturn] which can be
// overwritten with [WithChannelOptionNotifyReturn].
// It sends an [EventMessageReturned] kind of event over the notification channel
// (see [WithChannelOptionNotification]) with a literal error containing the return message ID.
func defaultNotifyReturn(msg amqp.Return, ch *Channel) <span class="cov0" title="0">{
        Event{
                SourceType: CliChannel,
                SourceName: ch.opt.name,
                Kind:       EventMessageReturned,
                Err: SomeErrFromString(
                        fmt.Sprintf("message %s returned", msg.MessageId),
                ),
        }.raise(ch.opt.notifier)
}</span>

// Channel returns the managed [Channel] which can be further used to extract [SafeBaseChan]
func (p *Publisher) Channel() *Channel <span class="cov0" title="0">{
        return p.channel
}</span>

// NewPublisher creates a publisher with the desired options.
// It creates and opens a new dedicated [Channel] using the passed shared connection.
func NewPublisher(conn *Connection, opt PublisherOptions, optionFuncs ...func(*ChannelOptions)) *Publisher <span class="cov0" title="0">{
        useParams := ChanUsageParameters{
                PublisherUsageOptions: opt.PublisherUsageOptions,
        }
        chanOpt := append(optionFuncs, WithChannelOptionUsageParams(useParams))

        return &amp;Publisher{
                channel: NewChannel(conn, chanOpt...),
                opt:     opt,
        }
}</span>

// AwaitDeferredConfirmation waits for the confirmation of a deferred action and updates its outcome.
//
// It takes in a deferred confirmation object and a time duration for the timeout.
// It returns the updated deferred confirmation object.
func (p *Publisher) AwaitDeferredConfirmation(d *DeferredConfirmation, tmr time.Duration) *DeferredConfirmation <span class="cov0" title="0">{
        if d.DeferredConfirmation == nil </span><span class="cov0" title="0">{
                d.Outcome = ConfirmationDisabled
                return d
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-time.After(tmr):<span class="cov0" title="0">
                d.Outcome = ConfirmationTimeOut</span>
        case &lt;-p.opt.Context.Done():<span class="cov0" title="0">
                d.Outcome = ConfirmationClosed</span>
        // FIXME: could this be triggered by recovery before the channel's context?
        case &lt;-d.Done():<span class="cov0" title="0">
                if d.RequestSequence &gt; d.DeliveryTag </span><span class="cov0" title="0">{
                        d.Outcome = ConfirmationPrevious
                }</span> else<span class="cov0" title="0"> if d.Acked() </span><span class="cov0" title="0">{
                        d.Outcome = ConfirmationACK
                }</span> else<span class="cov0" title="0"> {
                        d.Outcome = ConfirmationNAK
                }</span>
        }

        <span class="cov0" title="0">return d</span>
}

// Publish wraps the amqp.PublishWithContext using the internal [PublisherOptions]
// cached when the publisher was created.
func (p *Publisher) Publish(msg amqp.Publishing) error <span class="cov0" title="0">{

        if p.channel.IsClosed() </span><span class="cov0" title="0">{
                return amqp.ErrClosed
        }</span>

        <span class="cov0" title="0">return p.channel.PublishWithContext(
                p.opt.Context, p.opt.Exchange, p.opt.Key, p.opt.Mandatory, p.opt.Immediate,
                msg)</span>
}

// PublishDeferredConfirm wraps the amqp.PublishWithDeferredConfirmWithContext using the internal [PublisherOptions]
// cached when the publisher was created.
func (p *Publisher) PublishDeferredConfirm(msg amqp.Publishing) (*DeferredConfirmation, error) <span class="cov0" title="0">{
        if p.channel.IsClosed() </span><span class="cov0" title="0">{
                return nil, amqp.ErrClosed
        }</span>

        <span class="cov0" title="0">var err error
        confirmation := &amp;DeferredConfirmation{
                Outcome:         ConfirmationClosed,
                ChannelName:     p.channel.Name(),
                Queue:           p.channel.Queue(),
                RequestSequence: p.channel.GetNextPublishSeqNo(),
        }
        confirmation.DeferredConfirmation, err = p.channel.PublishWithDeferredConfirmWithContext(
                p.opt.Context, p.opt.Exchange, p.opt.Key, p.opt.Mandatory, p.opt.Immediate, msg)

        return confirmation, err</span>
}

// PublishWithOptions wraps the amqp.PublishWithContext using the passed options.
func (p *Publisher) PublishWithOptions(opt PublisherOptions, msg amqp.Publishing) error <span class="cov0" title="0">{

        if p.channel.IsClosed() </span><span class="cov0" title="0">{
                return amqp.ErrClosed
        }</span>

        <span class="cov0" title="0">return p.channel.PublishWithContext(
                opt.Context, opt.Exchange, opt.Key, opt.Mandatory, opt.Immediate,
                msg)</span>
}

// PublishDeferredConfirmWithOptions wraps the amqp.PublishWithDeferredConfirmWithContext using the passed options.
func (p *Publisher) PublishDeferredConfirmWithOptions(opt PublisherOptions, msg amqp.Publishing) (*DeferredConfirmation, error) <span class="cov0" title="0">{
        if p.channel.IsClosed() </span><span class="cov0" title="0">{
                return nil, amqp.ErrClosed
        }</span>

        <span class="cov0" title="0">var err error
        confirmation := &amp;DeferredConfirmation{
                Outcome:         ConfirmationClosed,
                ChannelName:     p.channel.Name(),
                Queue:           p.channel.Queue(),
                RequestSequence: p.channel.GetNextPublishSeqNo(),
        }
        confirmation.DeferredConfirmation, err = p.channel.PublishWithDeferredConfirmWithContext(
                opt.Context, opt.Exchange, opt.Key, opt.Mandatory, opt.Immediate, msg)

        return confirmation, err</span>
}

// Available returns the status of both the underlying connection and channel.
func (p *Publisher) Available() (bool, bool) <span class="cov0" title="0">{
        return !p.channel.conn.IsClosed(), !p.channel.IsClosed()
}</span>

// AwaitAvailable waits till the publisher infrastructure is ready or timeout expires.
// Useful when the connections and channels are about being created or recovering.
// When passing zero value parameter the defaults used are 7500ms for timeout and
// 330 ms for polling frequency.
func (p *Publisher) AwaitAvailable(timeout, pollFreq time.Duration) bool <span class="cov0" title="0">{
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 7500 * time.Millisecond
        }</span>
        <span class="cov0" title="0">if pollFreq == 0 </span><span class="cov0" title="0">{
                pollFreq = 330 * time.Millisecond
        }</span>

        // status polling
        <span class="cov0" title="0">ticker := time.NewTicker(pollFreq)
        defer ticker.Stop()
        done := make(chan bool)

        // session timeout
        go func() </span><span class="cov0" title="0">{
                time.Sleep(timeout)
                done &lt;- true
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-done:<span class="cov0" title="0">
                        return false</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if connUp, chanUp := p.Available(); connUp &amp;&amp; chanUp </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
}

// Close shuts down cleanly the publisher channel.
func (p *Publisher) Close() error <span class="cov0" title="0">{
        return p.channel.Close()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package grabbit

import "context"

// PublisherUsageOptions defines parameters for driving the publishers
// behavior and indicating to the supporting channel that publishing
// operations are enabled.
type PublisherUsageOptions struct {
        ConfirmationCount  int  // size of publishing confirmations over the amqp channel
        ConfirmationNoWait bool // publisher confirmation mode parameter
        IsPublisher        bool // indicates if this chan is used for publishing

}

// PublisherOptions defines publisher specific parameters. Mostly used as defaults for
// sending messages and inner channel functionality.
type PublisherOptions struct {
        PublisherUsageOptions
        Context   context.Context // controlling environment
        Exchange  string          // routing exchange
        Key       string          // routing key (usually queue name)
        Mandatory bool            // delivery is mandatory
        Immediate bool            // delivery is immediate
}

// DefaultPublisherOptions creates some sane defaults for publishing messages.
// Note: The Message/payload itself must still be an amqp.Publishing object,
// fully under application's control.
func DefaultPublisherOptions() PublisherOptions <span class="cov0" title="0">{
        return PublisherOptions{
                PublisherUsageOptions: PublisherUsageOptions{
                        ConfirmationCount:  10,
                        ConfirmationNoWait: false,
                        IsPublisher:        true,
                },
                Context:   context.TODO(),
                Exchange:  "",
                Key:       "",
                Mandatory: false,
                Immediate: false,
        }
}</span>

// WithConfirmationNoWait sets the ConfirmationNoWait field of the PublisherOptions struct.
//
// It takes a boolean parameter `confNoWait` and updates the `ConfirmationNoWait` field of the `PublisherOptions` struct to the value of `confNoWait`.
// It returns a pointer to the `PublisherOptions` struct.
func (opt *PublisherOptions) WithConfirmationNoWait(confNoWait bool) *PublisherOptions <span class="cov0" title="0">{
        opt.ConfirmationNoWait = confNoWait
        return opt
}</span>

// WithContext sets the context for the PublisherOptions.
//
// ctx: The context to be set.
// Returns: A pointer to PublisherOptions.
func (opt *PublisherOptions) WithContext(ctx context.Context) *PublisherOptions <span class="cov0" title="0">{
        opt.Context = ctx
        return opt
}</span>

// WithExchange sets the exchange for the PublisherOptions struct.
//
// Parameters:
// - exchange: The exchange to set.
//
// Returns:
// - *PublisherOptions: The updated PublisherOptions struct.
func (opt *PublisherOptions) WithExchange(exchange string) *PublisherOptions <span class="cov0" title="0">{
        opt.Exchange = exchange
        return opt
}</span>

// WithKey sets the key for the PublisherOptions.
//
// key: the key to set.
// returns: a pointer to the PublisherOptions.
func (opt *PublisherOptions) WithKey(key string) *PublisherOptions <span class="cov0" title="0">{
        opt.Key = key
        return opt
}</span>

// WithMandatory sets the mandatory flag in the PublisherOptions struct.
//
// Parameters:
// - mandatory: a boolean indicating whether the field should be mandatory.
//
// Returns:
// - *PublisherOptions: a pointer to the PublisherOptions struct.
func (opt *PublisherOptions) WithMandatory(mandatory bool) *PublisherOptions <span class="cov0" title="0">{
        opt.Mandatory = mandatory
        return opt
}</span>

// WithImmediate sets the immediate flag of the PublisherOptions struct.
//
// It takes a boolean parameter `immediate` and returns a pointer to the updated PublisherOptions.
func (opt *PublisherOptions) WithImmediate(immediate bool) *PublisherOptions <span class="cov0" title="0">{
        opt.Immediate = immediate
        return opt
}</span>

// WithConfirmationsCount sets the number of confirmations required for publishing.
//
// count: The number of confirmations required.
// *PublisherOptions: The updated PublisherOptions object.
func (opt *PublisherOptions) WithConfirmationsCount(count int) *PublisherOptions <span class="cov0" title="0">{
        opt.ConfirmationCount = count
        return opt
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package grabbit

import (
        amqp "github.com/rabbitmq/amqp091-go"
)

// TopologyBind defines the possible binding relation between exchanges or queues and exchanges.
type TopologyBind struct {
        Enabled bool       // want this re-routing
        Peer    string     // other end of routing
        Key     string     // routing key / filter
        NoWait  bool       // re-routing confirmation required
        Args    amqp.Table // core properties
}

// TopologyOptions defines the infrastructure topology, i.e. exchange and queues definition
// when wanting handling automatically on recovery or one time creation
type TopologyOptions struct {
        Name          string       // tag of exchange or queue
        IsDestination bool         // end target, i.e. if messages should be routed to it
        IsExchange    bool         // indicates if this an exchange or queue
        Bind          TopologyBind // complex routing
        Kind          string       // empty string for default exchange or: direct, topic, fanout, headers.
        Durable       bool         // maps the durable amqp attribute
        AutoDelete    bool         // maps the auto-delete amqp attribute
        Exclusive     bool         // if queue is exclusive
        Internal      bool         //
        NoWait        bool         // // maps the noWait amqp attribute
        Passive       bool         // if false, it will be created on the server when missing
        Args          amqp.Table   // wraps the amqp Table parameters
        Declare       bool         // gets created on start and also during recovery if Durable is false
}

// GetRouting returns the source and destination strings for the TopologyOptions struct.
//
// The source and destination strings are determined based on whether IsDestination is true or false.
//   - if IsDestination is true, the source string is set to t.Bind.Peer and the destination string is set to t.Name.
//   - if IsDestination is false, the source string is set to t.Name and the destination string is set to t.Bind.Peer.
//
// Returns the source and destination strings.
func (t *TopologyOptions) GetRouting() (source, destination string) <span class="cov0" title="0">{
        if t.IsDestination </span><span class="cov0" title="0">{
                return t.Bind.Peer, t.Name
        }</span> else<span class="cov0" title="0"> {
                return t.Name, t.Bind.Peer
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
